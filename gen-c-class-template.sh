#!/bin/bash
# 
# Source code generator for classes in ANSI C
#
# (c) 2018 by Matthias Arndt <marndt@asmsoftware.de>
#
# The MIT License applies to this project. See LICENSE for details.
#
# Basic operating principle: 
# file templates are generated with placeholders CLASSNAME inside,
# the placeholders are then replaced with the actual class name to be used
#---------------------------------------
# internal functions to generate file contents for given sections
# first argument is the file to place the code into
#---------------------------------------

# create Doxygen header for given file
# param 1 denotes the filename
# param 2 denotes Doxygen brief description start word
create_header() {
    echo "" >${1}
    fname=`basename ${1}`
    
    cat <<EOF >>${1}
/**
 * @file    ${fname}
 * @brief   ${2} of class CLASSNAME
 * @details
 */

/**
 * @addtogroup CLASSNAME
 * @{
 */

EOF
}

# create Doxygen and ANSI C file footer for given file
# param 1 denotes the filename
create_footer () {

    cat <<EOF >>${1}
/**
 * @}
 */

/* code generated by gen-c-class-template (c) 2018 by Matthias Arndt <marndt@asmsoftware.de> */


EOF
    
}

# create C comment section with text inside given file
# param 1 denotes the filename
# param 2 denotes the comment
create_section () {

    cat <<EOF >>${1}
/* --------------------------------------------------------------------------
 * ${2}
 * --------------------------------------------------------------------------
 */

EOF
    
}

# create C comment section with text inside given file
# param 1 denotes the filename
create_includes () {

    cat <<EOF >>${1}

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "CLASSNAME.h"

EOF
    
}

# create template for class member definition inside given file
# param 1 denotes the filename
create_class_struct () {

    cat <<EOF >>${1}
/**
 * @brief member definition for class CLASSNAME
 */
struct CLASSNAME
{
    /* TODO define your class member variables here */
};

EOF
    
}

# create module local variables to provide possible instances
# param 1 denotes the filename
create_instancemgr_simple () {

    cat <<EOF >>${1}

/**
 * @brief memory pool for instance of class CLASSNAME
 */
static struct CLASSNAME CLASSNAME_pool[NR_CLASSNAME];

/**
 * @brief internal counter for allocated instances of class CLASSNAME
 */
static uint16_t CLASSNAME_instancecnt = 0;

EOF
}

# create constructor and destructor implementation using malloc/free
# param 1 denotes the filename
create_constructors_malloc () {

    cat <<EOF >>${1}    
/**
 * @brief   allocate memory for an instance of class CLASSNAME
 * @details All members are initialized to 0.
 * @return  pointer to new instance, NULL in case of error
 */
CLASSNAME CLASSNAME_New(void)
{
    return (CLASSNAME) calloc(1, sizeof(struct CLASSNAME));
}

/**
 * @brief frees instance of class CLASSNAME and returns memory to the OS
 */
void CLASSNAME_Delete(CLASSNAME self)
{
    free((void *)self);
}

EOF
    
}

# create constructor and destructor implementation using localized instance management
# param 1 denotes the filename
create_constructors_simple () {

    cat <<EOF >>${1}    
/**
 * @brief   allocate memory for an instance of class CLASSNAME
 * @details All members are initialized to 0. Maximum number of possible instances is limited.
 * @return  pointer to new instance, NULL in case of error
 */
CLASSNAME CLASSNAME_New(void)
{
    CLASSNAME new_instance = NULL;
    
    assert((CLASSNAME_instancecnt < NR_CLASSNAME));
    
    if(CLASSNAME_instancecnt < NR_CLASSNAME)
    {
        new_instance = &CLASSNAME_pool[CLASSNAME_instancecnt++];
    }

    return new_instance;
}

/**
 * @brief   frees instance of class CLASSNAME and returns memory to the OS
 * @details This is a dummy call.
 */
void CLASSNAME_Delete(CLASSNAME self)
{
    (void)self;
}

EOF
    
}

# provide definition of maximum instances for simple generator scheme
# param 1 denotes the filename
create_instancemgr_define () {

    cat <<EOF >>${1}

#ifndef NR_CLASSNAME
    /**
     * @brief maximum number of possible instances of class CLASSNAME
     */     
    #define NR_CLASSNAME  1
    #pragma message("- max. 1 instance of CLASSNAME allocatable")
#endif

#if(NR_CLASSNAME < 1)
    #error "- NR_CLASSNAME given is bogus"
#endif

EOF
}


# create header file with basic type definitions and prototypes
# param 1 denotes the filename
create_hfile_content () {

    UPPERCASE_CLASSNAME=`echo $CLASSNAME | tr '[a-z]' '[A-Z]'`

    cat <<EOF >>${1}

#ifndef ${UPPERCASE_CLASSNAME}_H
    #define ${UPPERCASE_CLASSNAME}_H
    
    #include <stdint.h>
    
    /**
     * @brief member definition for class CLASSNAME
     */
    struct CLASSNAME;
    
    /**
     * @brief pointer to instances of class CLASSNAME
     */
    typedef struct CLASSNAME * CLASSNAME;
    
    /**
     * @brief constructor for instances of class CLASSNAME
     */
    CLASSNAME CLASSNAME_New(void);
        
    /**
     * @brief destructor for instances of class CLASSNAME
     */
    void CLASSNAME_Delete(CLASSNAME self);
    
#endif    

EOF
    
}

print_help () {
    echo
    echo "Usage: $1 [-malloc|-simple] <classname>"
    echo
    echo "-malloc generates constructors using calloc() calls and destructors use free() to release memory"
    echo "-simple generates constructors to provide internally manages instances, destructors are empty"
    echo
    echo "Default behaviour is -malloc"
    echo

    exit -1
}

#---------------------------------------
# main program
#---------------------------------------
# some notice at startup
echo "Source code generator for classes in ANSI C"
echo "(c) 2018 by Matthias Arndt <marndt@asmsoftware.de>"
CLASSNAME_input=""
CONSTRUCTOR="-malloc"
# parse command line
for argv in "$@"
do
    if [[ $argv == -* ]]
    then      
        # check for known arguments
        case "$argv" in
        
            "-malloc")
            CONSTRUCTOR="-malloc"
            ;;
            
            "-simple")
            CONSTRUCTOR="-simple"
            ;;
            
            *)
            print_help $0           
            exit -1
            ;;
        
        esac
        
    else
        # class to generate was found:
        CLASSNAME_input=$argv
        break
    fi

done

if [[ $CLASSNAME_input == "" ]]
then
    print_help $0
    exit -1
fi

# variables used
CLASSNAME=$(echo ${CLASSNAME_input}|tr -cd '[:alnum:]_')
CFILE=${CLASSNAME}.c
HFILE=${CLASSNAME}.h
# information output on working state
echo "Class generated.....:" $CLASSNAME
echo ".c file generated...:" $CFILE
echo ".h file generated...:" $HFILE
# backup existing files
if [ -f $CFILE ]; then
    echo "Backup ${CFILE} before generating code..."
    cp ${CFILE} ${CFILE}.bak
fi
if [ -f $HFILE ]; then
    echo "Backup ${HFILE} before generating code..."
    cp ${HFILE} ${HFILE}.bak
fi
# generate new .c file
create_header ${CFILE} implementation
create_includes ${CFILE}
create_section ${CFILE} "class member definition"
create_class_struct ${CFILE}
create_section ${CFILE} "local definitions"
if [[ $CONSTRUCTOR == "-simple" ]]
then
    create_instancemgr_define ${CFILE}
    create_section ${CFILE} "local variables"
    create_instancemgr_simple ${CFILE}
fi
create_section ${CFILE} "local methods"
create_section ${CFILE} "public methods"
if [[ $CONSTRUCTOR == "-malloc" ]]
then
    create_constructors_malloc ${CFILE}
else
    create_constructors_simple ${CFILE}
fi
create_footer ${CFILE}

#generate new .h file
create_header ${HFILE} "public API"
create_hfile_content ${HFILE}
create_footer ${HFILE}

# replace placeholders with name of generated class
sed -i "s/CLASSNAME/${CLASSNAME}/g" ${CFILE}
sed -i "s/CLASSNAME/${CLASSNAME}/g" ${HFILE}
echo "...finished"
